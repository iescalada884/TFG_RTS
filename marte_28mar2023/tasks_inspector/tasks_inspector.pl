#!/usr/bin/perl -w
#----------------------------------------------------------------------------
#--------------------        M a R T E     O S        -----------------------
#----------------------------------------------------------------------------
#
#                     't a s k s _ i n s p e c t o r'
#
#                             Perl Script
#
#
# File 'tasks_inspector.pl'                                          By MAR.
#

# This script translates a file with scheduling events generated by
# MaRTE OS in another set of files to be read for 'gnuplot'.

# Use:
#     $ tasks_inspector <event_file>

# Having the events file the following structure:
#
#    Empty or irrelevant lines    
#    #0#ID(12,31)#
#    #0#CF(Clock_freq/10,0)#
#    #130374414940538808#TR(0,0)#
#    #130374415072730860#NT(1,5)#
#    #130374415073083994#TR(1,5)#
#    #130374415073711017#NT(2,5)#
#    #130374415074310073#NT(3,5)#
#    #130374415074946417#NT(4,5)#
#    #130374415075306926#TB(0,7)#
#    #130374415075653761#CS(0,7)->(1,5)#
#    #130374415076936269#TR(2,5)#
#    ...

# (The value of the clock frequency is divided by 10 to avoid going
# over the integer maximum value).

# The tasks and mutexes are printed with the following value depending
# on their state and priority.

#
#                         |  mutex locked -> $MUTEXES                       |
#                         |                  + (2*$PRIO_GAP*(id-$NTASKS))   | 
#                         |                  + $PRIO_GAP                    |
#                         |  free mutex -> $MUTEXES                         |
#                         |                + (2*$PRIO_GAP*(id-$NTASKS))     |
# $MUTEXES = $RUNNING     +-------------------------------------------------+
#          + $PRIO_GAP    |                                                 |
#               * $NPRIOS |                                                 |
#                         | Running tasks -> $RUNNING + prio*$PRIO_GAP + id |
# $RUNNING = $PRIO_GAP    +-------------------------------------------------+
#              * $NPRIOS  |                                                 |
#                         | Ready tasks -> $READY + prio*$PRIO_GAP + id     |
#                         |                                                 |
#                         |                                                 |
# $READY = 0              +-------------------------------------------------+
#                         |                                                 |
#                         | Blocked tasks -> $BLOCKED + id                  |
#                         |                                                 |
# $BLOCKED = -2*$PRIO_GAP +-------------------------------------------------+
#                         |                                                 |
#                         | Terminated tasks -> $BLOCKED + id               |
# $TERMINATED =           |                                                 |
#           -4*$PRIO_GAP  +-------------------------------------------------+

#---------------------------------------------------------------------------*/
use strict;
use warnings;

#require ti_write_gnuplot_files;        # write files for GNU Plot
require ti_trace_file;  # gets information from MaRTE traces

# Subfunction declaration
sub exec_command;
sub exec_command_no_echo;

# Global variables
my $DBG = 1;
my $NTASKS;
my $NMUTEXES;
my $LOW_PRIO;
my $HIGH_PRIO;
my $NPRIOS;
my $MAIN_INITIAL_PRIO;

# drawing global variables
my $PRIO_GAP;
my $BLOCKED;
my $TERMINATED;
my $READY;
my $RUNNING;
my $MUTEXES;

# Ids of special tasks
my $MAIN_ID = 0;
my $IDLE_ID = 1;

$#ARGV == 0 or die "use: task_inspector events_file";

#
# open the traces file and get the global data
#
($NTASKS, $NMUTEXES, $LOW_PRIO, $HIGH_PRIO, $MAIN_INITIAL_PRIO) = 
    ti_trace_file::open($ARGV[0]); 
$NPRIOS = $HIGH_PRIO - $LOW_PRIO + 1;

print "Traces global information:\n";
print "  - Number of tasks: $NTASKS\n";
print "  - Number of mutexes: $NMUTEXES\n";
print "  - Priority range: [$LOW_PRIO, $HIGH_PRIO]\n";
print "  - Main initial prio: $MAIN_INITIAL_PRIO\n";


#
# Procces the trace
#

# initialize data
my @values = ();
my @last_value = ();
my @id_used = ();
my @ready = ();
for (my $i = 0; $i<$NTASKS + $NMUTEXES; $i++) {
    $values[$i] = "";
    $last_value[$i] = 0;
    $id_used[$i] = 0;
    $ready[$i] = 0;
}
$ready[$MAIN_ID] = 1; # The main task starts ready
$ready[$IDLE_ID] = 1; # The idle task starts ready

# The idle tasks could be silent but it always exists
$id_used[$IDLE_ID] = 1;
$last_value[$IDLE_ID] = $READY + $IDLE_ID;
$values[$IDLE_ID] .= "0  " . ($last_value[$IDLE_ID]) . "\n";

# The main task starts running
my $running_id = 0;
$id_used[$MAIN_ID] = 1;
$last_value[$MAIN_ID] = $RUNNING + $main_initial_prio*$PRIO_GAP;
$values[$MAIN_ID] .= "0  " . ($last_value[0]) . "\n";

# Analice each scheduling event
my $id;
my $prio;
my $ts;
foreach $event (@events) {


# -------------------------------------------------------------------
# subfunctions: exec_command

sub exec_command
{
    my $cmd = shift(@_);
    printf "$cmd\n";
    system ($cmd) == 0 or die "Can't execute $cmd\n";
}

sub exec_command_no_echo
{
    my $cmd = shift(@_);
    #printf "$cmd\n";
    system ($cmd) == 0 or die "Can't execute $cmd\n";
}


